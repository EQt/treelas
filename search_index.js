var documenterSearchIndex = {"docs":
[{"location":"tree_dp.html#Dynamic-Programming-Tree-Solver-1","page":"Tree Solver","title":"Dynamic Programming Tree Solver","text":"","category":"section"},{"location":"tree_dp.html#","page":"Tree Solver","title":"Tree Solver","text":"TreeLas.TreeDP\nTreeLas.TreeDP.tree_dp\nTreeLas.TreeDP.tree_dp!\nTreeLas.TreeDP.TreeDPMem\nTreeLas.TreeDP.reset!","category":"page"},{"location":"tree_dp.html#TreeLas.TreeDP","page":"Tree Solver","title":"TreeLas.TreeDP","text":"Dynamic Programming Tree Solver\n\nMerge the event queues within the tree by sorting arrays.\n\nCompared to previous versions, all weighting (λ and μ) is templated; thus we only need one implementation and the compiler will do the rest.\n\n\n\n\n\n","category":"module"},{"location":"tree_dp.html#TreeLas.TreeDP.tree_dp","page":"Tree Solver","title":"TreeLas.TreeDP.tree_dp","text":"tree_dp(y, t::Tree, λ [, μ = 1.0])\n\nPerform the dynamic programming algorithm on y and return the optimized x.\n\nThe edge weighting λ should be either a constant (e.g. Float64) or a callable such that λ(i) returns the weight of the edge (i, t.parent[i]); for λ(t.root) it might return anything but not causean error.\n\n\n\n\n\n","category":"function"},{"location":"tree_dp.html#TreeLas.TreeDP.tree_dp!","page":"Tree Solver","title":"TreeLas.TreeDP.tree_dp!","text":"tree_dp!(x, y, t, λ, μ [,mem])\n\nLike tree_dp but do not allocate an output buffer for x.\n\nIf mem::TreeDPMem is provided, no additional allocations will be needed.\n\n\n\n\n\n","category":"function"},{"location":"tree_dp.html#TreeLas.TreeDP.TreeDPMem","page":"Tree Solver","title":"TreeLas.TreeDP.TreeDPMem","text":"Contains all memory needed for tree_dp!.\n\n\n\n\n\n","category":"type"},{"location":"tree_dp.html#GraphIdx.Tree.reset!","page":"Tree Solver","title":"GraphIdx.Tree.reset!","text":"reset!(mem::TreeDPMem, t::Tree)\n\nRe-initialize the memory given the new tree, i.e.\n\nAssert that mem has the required size for t.\nCompute processing order.\nInitialize queues to fit t.\n\n\n\n\n\n","category":"function"},{"location":"tree_dp.html#Dual-Solution-1","page":"Tree Solver","title":"Dual Solution","text":"","category":"section"},{"location":"tree_dp.html#","page":"Tree Solver","title":"Tree Solver","text":"Modules = [TreeLas.Dual]","category":"page"},{"location":"tree_dp.html#TreeLas.Dual.dual!-Union{Tuple{I}, Tuple{N}, Tuple{F}, Tuple{Array{F,1},Array{F,N},Array{F,N},Array{I,1},Array{I,1}}, Tuple{Array{F,1},Array{F,N},Array{F,N},Array{I,1},Array{I,1},F}} where I where N where F","page":"Tree Solver","title":"TreeLas.Dual.dual!","text":"dual!(α, [, x, y], post_order, parent)\n\nCompute the tree dual and store it in α.\n\n\n\n\n\n","category":"method"},{"location":"tree_dp.html#TreeLas.Dual.gap_vec!","page":"Tree Solver","title":"TreeLas.Dual.gap_vec!","text":"gap_vec!(γ, dif, x, y, D, Dt, α, c)\n\nCompute the gap vector (modifies dif and x) and stores it in γ.\n\nwarning: Warning\nThis is the old method using Julia's SparseArrays.SparseMatrixCSC.\n\n\n\n\n\n","category":"function"},{"location":"tree_dp.html#TreeLas.Dual.gap_vec!-Union{Tuple{Graph}, Tuple{F}, Tuple{Array{F,1},Array{F,N} where N,Array{F,1},Graph}, Tuple{Array{F,1},Array{F,N} where N,Array{F,1},Graph,F}} where Graph where F<:Real","page":"Tree Solver","title":"TreeLas.Dual.gap_vec!","text":"gap_vec!(γ, x, α, g [, c = 1.0])\n\nCompute the duality gap: for each edge e we set γ[e] to the difference of the edge cost lambda_ij x_i - x_j and the linear approximation via the dual α_ij(x_i - x_j).\n\nThe graph g needs to implement a method enumerate_edges(::Function, g).\n\nIf provided, the result is multiplied by c.\n\n\n\n\n\n","category":"method"},{"location":"tree_dp.html#TreeLas.Dual.primal_from_dual!-Union{Tuple{G}, Tuple{N}, Tuple{F}, Tuple{Array{F,N},Array{F,1},G}} where G where N where F<:Real","page":"Tree Solver","title":"TreeLas.Dual.primal_from_dual!","text":"primal_from_dual!(y, α, graph)\n\nSimilar to primal_from_dual but store the result in y.\n\n\n\n\n\n","category":"method"},{"location":"tree_dp.html#TreeLas.Dual.primal_from_dual-Union{Tuple{G}, Tuple{N}, Tuple{F}, Tuple{Array{F,N},Array{F,1},G}} where G where N where F","page":"Tree Solver","title":"TreeLas.Dual.primal_from_dual","text":"primal_from_dual(y, α, graph)\n\nIf D is the oriented incidence matrix of graph, return y + D*α.\n\n\n\n\n\n","category":"method"},{"location":"tree_dp.html#TreeLas.Dual.wolfe_gap_step-Union{Tuple{Graph}, Tuple{F}, Tuple{Array{F,N} where N,Array{F,1},Array{F,N} where N,Array{F,1},Graph}} where Graph where F<:Real","page":"Tree Solver","title":"TreeLas.Dual.wolfe_gap_step","text":"wolfe_gap_step(x0, α0, x1, α1)\n\nOptimal gap step width according to Wolfe's condition, i.e. compute the optimal step width θ  0 1 to walk from (x0, α0) to (x1, α1) such that the sum(gap_vec) will be minimized.\n\n\n\n\n\n","category":"method"},{"location":"tree_dp.html#Queues-Structure-1","page":"Tree Solver","title":"Queues-Structure","text":"","category":"section"},{"location":"tree_dp.html#","page":"Tree Solver","title":"Tree Solver","text":"The main component is a set of double-ended, mergable priority queues (also called heaps).","category":"page"},{"location":"tree_dp.html#","page":"Tree Solver","title":"Tree Solver","text":"Modules = [TreeLas.Pwl.QueueUnion]","category":"page"},{"location":"tree_dp.html#TreeLas.Pwl.QueueUnion.Queues","page":"Tree Solver","title":"TreeLas.Pwl.QueueUnion.Queues","text":"Set of double ended queues (DeQue) in a tree. Initially all leaf nodes have its own queue. Children's queues will be merged into the parent node.\n\n\n\n\n\n","category":"type"},{"location":"tree_dp.html#TreeLas.Pwl.QueueUnion.Range","page":"Tree Solver","title":"TreeLas.Pwl.QueueUnion.Range","text":"Range(start, stop)\n\nA range in a Vector. In our algorithm is is used for the nodes of Queues of Events.\n\nwarning: Warning\nunlike in Python, start and stop are inclusive!\n\n\n\n\n\n","category":"type"},{"location":"pwl.html#Piece-wise-Linear-Functions-1","page":"Piecewise-Linear","title":"Piece-wise Linear Functions","text":"","category":"section"},{"location":"pwl.html#","page":"Piecewise-Linear","title":"Piecewise-Linear","text":"The dynamic programming algorithm computes for each node i (from bottom leaf to top root) the derivatives of the objective function restricted to the subtree starting at  i. It turns out that the derivative is always a piecewise-linear function. Therefore it suffices to store the kinks.","category":"page"},{"location":"pwl.html#","page":"Piecewise-Linear","title":"Piecewise-Linear","text":"Passing over a kink is called an event; the information that defines it is stored in","category":"page"},{"location":"pwl.html#","page":"Piecewise-Linear","title":"Piecewise-Linear","text":"TreeLas.Pwl\nTreeLas.Pwl.Event","category":"page"},{"location":"pwl.html#TreeLas.Pwl","page":"Piecewise-Linear","title":"TreeLas.Pwl","text":"Piecewise linear functions, stored in terms of an array of kinks (i.e. events).\n\n\n\n\n\n","category":"module"},{"location":"pwl.html#TreeLas.Pwl.Event","page":"Piecewise-Linear","title":"TreeLas.Pwl.Event","text":"Change of the derivative.\n\n\n\n\n\n","category":"type"},{"location":"pwl.html#","page":"Piecewise-Linear","title":"Piecewise-Linear","text":"The change (Delta) in the intercept is given by","category":"page"},{"location":"pwl.html#","page":"Piecewise-Linear","title":"Piecewise-Linear","text":"TreeLas.Pwl.intercept","category":"page"},{"location":"pwl.html#TreeLas.Pwl.intercept","page":"Piecewise-Linear","title":"TreeLas.Pwl.intercept","text":"intercept(e)\n\nIntercept (also called offset); implicitly encoded in the Event.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Tree-Fused-Lasso-1","page":"TreeLas","title":"Tree Fused Lasso","text":"","category":"section"},{"location":"index.html#","page":"TreeLas","title":"TreeLas","text":"Modules = [TreeLas]","category":"page"},{"location":"index.html#TreeLas.TreeLas","page":"TreeLas","title":"TreeLas.TreeLas","text":"Fused Lasso Solver for tree graphs, i.e. we aim to minimize the following objective function\n\nf(x) = frac12 sum_i=1^n mu_i (x_i - y_i)^2 + sum_(ij) in E lambda_ij x_i - x_j\n\nHereby is\n\ny_i the input signal for node i,\nmu_i geq 0 is the node weight for node i,\nE the edges of a tree, and\nlambda_ij  0 is the edge weight for (ij).\n\n\n\n\n\n","category":"module"},{"location":"index.html#Exact-Tree-Solver-1","page":"TreeLas","title":"Exact Tree Solver","text":"","category":"section"},{"location":"index.html#","page":"TreeLas","title":"TreeLas","text":"The exact solver is found in the module TreeLas.TreeDP.","category":"page"},{"location":"index.html#General-Graphs-1","page":"TreeLas","title":"General Graphs","text":"","category":"section"},{"location":"index.html#","page":"TreeLas","title":"TreeLas","text":"Furtheron, we presend a general graph solver that iteratively picks a subtree and block-optimizes it.","category":"page"},{"location":"index.html#","page":"TreeLas","title":"TreeLas","text":"Modules = [TreeLas.MGT]","category":"page"},{"location":"index.html#TreeLas.MGT","page":"TreeLas","title":"TreeLas.MGT","text":"Maximum Gap Tree\n\nAlso called Gap Tree Lasso (GapLas).\n\nIn the central function gaplas, a tree having the largest gap values (computed by gap_vec!) is selected.  The non-tree edge-flows are forwarded into the input y.  Then the tree solver is used and the tree-edges are updated.\n\nGraph Indexes\n\nFor the different steps, several indexes are necessary\n\nDual.gap_vec! needs to access every edge once.\nPrim's minimum spanning tree: IncidenceIndex providing outgoing edges for a node (i.e. every edge is included in two node's adjacency lists)\nOnce the tree has been determined we need to have a ChildrenIndex from the parent (e.g. for dfs_walk); also needed for computing the Queues layout (parenthesis tree representation) and the processing order.\n\nRefactoring\n\nIn principle, it is not necessary to actually compute and store the edges (and weights); it suffices to have access via enumerate_edges or alike.\n\n\n\n\n\n","category":"module"},{"location":"index.html#TreeLas.MGT.duality_check-Tuple{Any,Any}","page":"TreeLas","title":"TreeLas.MGT.duality_check","text":"Ensure that the alpha is dually feasible, i.e. componentwise absolutely not greater than lambda.\n\n\n\n\n\n","category":"method"},{"location":"index.html#TreeLas.MGT.gaplas!-Union{Tuple{Graph}, Tuple{Array{Float64,N} where N,Array{Float64,1},Array{Float64,1},Array{Float64,N} where N,Graph}} where Graph","page":"TreeLas","title":"TreeLas.MGT.gaplas!","text":"gaplas!(...)\n\nPerform one iteration. Premises:\n\nx = y + D'*α\nα dually feasible, abs(α[e]) ≤ λ[e] for all edges e.\n\n\n\n\n\n","category":"method"},{"location":"index.html#TreeLas.MGT.gaplas-Union{Tuple{Fu3}, Tuple{Fu2}, Tuple{Fu1}, Tuple{N}, Tuple{E}, Tuple{Array{Float64,N},Array{E,1},Array{Float64,1}}} where Fu3<:Function where Fu2<:Function where Fu1<:Function where N where E","page":"TreeLas","title":"TreeLas.MGT.gaplas","text":"gaplas(y, edges, λ; learn=1.0, max_iter=3, ...)\n\nOptimize in each iteration along a tree.\n\nThe learn parameter controls how much of the new tree solution should be taken (should be between 0 and 10).\n\n\n\n\n\n","category":"method"},{"location":"index.html#TreeLas.MGT.gaplas-Union{Tuple{Graph}, Tuple{Array{Float64,N} where N,Graph}} where Graph","page":"TreeLas","title":"TreeLas.MGT.gaplas","text":"gaplas(...)\n\nGraph has to implement several methods:\n\niter_edges(::Function, ::Graph)\nIncidenceIndex(::Graph)\n\n\n\n\n\n","category":"method"},{"location":"index.html#TreeLas.MGT.update_tree!-NTuple{5,Any}","page":"TreeLas","title":"TreeLas.MGT.update_tree!","text":"update_tree!(α, αt, selected, edges, parent)\n\nUpdate the global dual α by a tree dual αt.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Utility-Functions-1","page":"TreeLas","title":"Utility Functions","text":"","category":"section"},{"location":"index.html#","page":"TreeLas","title":"TreeLas","text":"Modules = [TreeLas.Utils]","category":"page"},{"location":"index.html#TreeLas.Utils.primal_objective-Union{Tuple{F2}, Tuple{F1}, Tuple{G}, Tuple{N}, Tuple{F}, Tuple{Array{F,N},Array{F,N},G}, Tuple{Array{F,N},Array{F,N},G,F2}} where F2 where F1 where G where N where F","page":"TreeLas","title":"TreeLas.Utils.primal_objective","text":"primal_objective(x, y, graph [, mu])\n\nCompute the objective function, i.e.\n\nfrac12 sum_i=1^n μ_i (x_i - y_i)^2 + sum_(ij) in E λ_ij x_i - x_j\n\nHereby the edges (and edge weights λ_ij) are obtained via enumerate_edges(graph).\n\n\n\n\n\n","category":"method"},{"location":"index.html#TreeLas.Utils.sum2-Union{Tuple{Array{F,N}}, Tuple{N}, Tuple{F}} where N where F<:Real","page":"TreeLas","title":"TreeLas.Utils.sum2","text":"sum2(x)\n\nSum of squares.\n\njulia> TreeLas.Utils.sum2([1, 11])\n122\n\n\n\n\n\n\n","category":"method"},{"location":"graphidx.index.html#GraphIdx-1","page":"GraphIdx","title":"GraphIdx","text":"","category":"section"},{"location":"graphidx.index.html#","page":"GraphIdx","title":"GraphIdx","text":"Most of the code builds on top of a graph library called GraphIdx.","category":"page"},{"location":"graphidx.index.html#","page":"GraphIdx","title":"GraphIdx","text":"out = joinpath(pwd(), \"graphidx\")\n@info(\"Generating GraphIdx documentation\", out)\ncd(\"../../deps/graphidx/docs\") do\n    run(`env HTML_DIR=$out $(Base.julia_cmd()) --color=yes make.jl`)\nend\n@info(\"GraphIdx DONE\")\nnothing","category":"page"},{"location":"graphidx.index.html#","page":"GraphIdx","title":"GraphIdx","text":"The GraphIdx documentation is a separate subpage.","category":"page"}]
}
