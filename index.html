<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TreeLas · TreeLas</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TreeLas</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">TreeLas</a><ul class="internal"><li><a class="toctext" href="#Exact-Tree-Solver-1">Exact Tree Solver</a></li><li><a class="toctext" href="#General-Graphs-1">General Graphs</a></li><li><a class="toctext" href="#Utility-Functions-1">Utility Functions</a></li></ul></li><li><a class="toctext" href="tree_dp.html">Tree Solver</a></li><li><a class="toctext" href="pwl.html">Piecewise-Linear</a></li><li><a class="toctext" href="graphidx.index.html">GraphIdx</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">TreeLas</a></li></ul><a class="edit-page" href="https://github.com/EQt/treelas/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>TreeLas</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tree-Fused-Lasso-1" href="#Tree-Fused-Lasso-1">Tree Fused Lasso</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TreeLas.TreeLas" href="#TreeLas.TreeLas"><code>TreeLas.TreeLas</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Fused Lasso Solver for tree graphs, i.e. we aim to <strong>minimize</strong> the following objective function</p><div>\[f(x) = \frac{1}{2} \sum_{i=1}^n \mu_i (x_i - y_i)^2 + \sum_{(i,j) \in E} \lambda_{ij} |x_i - x_j|\]</div><p>Hereby is</p><ul><li><span>$y_i$</span> the input signal for node <span>$i$</span>,</li><li><span>$\mu_i \geq 0$</span> is the node weight for node <span>$i$</span>,</li><li><span>$E$</span> the edges of a tree, and</li><li><span>$\lambda_{ij} &gt; 0$</span> is the edge weight for <span>$(i,j)$</span>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/EQt/treelas/blob/8618395a4b17fcaec8da63cf391ab5822e6e1fbb/julia/src/TreeLas.jl#L1-L12">source</a></section><h2><a class="nav-anchor" id="Exact-Tree-Solver-1" href="#Exact-Tree-Solver-1">Exact Tree Solver</a></h2><p>The exact solver is found in the module <a href="tree_dp.html#TreeLas.TreeDP"><code>TreeLas.TreeDP</code></a>.</p><h2><a class="nav-anchor" id="General-Graphs-1" href="#General-Graphs-1">General Graphs</a></h2><p>Furtheron, we presend a general graph solver that iteratively picks a subtree and block-optimizes it.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TreeLas.MGT" href="#TreeLas.MGT"><code>TreeLas.MGT</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>Maximum Gap Tree</strong></p><p>Also called <strong>Gap Tree Lasso (GapLas)</strong>.</p><p>In the central function <code>gaplas</code>, a tree having the largest gap values (computed by <code>gap_vec!</code>) is selected.  The non-tree edge-flows are forwarded into the input <code>y</code>.  Then the tree solver is used and the tree-edges are updated.</p><p><strong>Graph Indexes</strong></p><p>For the different steps, several indexes are necessary</p><ol><li><p><a href="@ref"><code>Dual.gap_vec!</code></a> needs to access every edge once.</p></li><li><p>Prim&#39;s minimum spanning tree: <code>IncidenceIndex</code> providing outgoing edges for a node (i.e. every edge is included in two node&#39;s adjacency lists)</p></li><li><p>Once the tree has been determined we need to have a <code>ChildrenIndex</code> from the <code>parent</code> (e.g. for <code>dfs_walk</code>); also needed for computing the <code>Queues</code> layout (parenthesis tree representation) and the processing order.</p></li></ol><p><strong>Refactoring</strong></p><p>In principle, it is not necessary to actually compute and store the edges (and weights); it suffices to have access via <code>enumerate_edges</code> or alike.</p></div></div><a class="source-link" target="_blank" href="https://github.com/EQt/treelas/blob/8618395a4b17fcaec8da63cf391ab5822e6e1fbb/julia/src/mgt.jl#L1-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TreeLas.MGT.duality_check-Tuple{Any,Any}" href="#TreeLas.MGT.duality_check-Tuple{Any,Any}"><code>TreeLas.MGT.duality_check</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Ensure that the alpha is dually feasible, i.e. componentwise absolutely not greater than lambda.</p></div></div><a class="source-link" target="_blank" href="https://github.com/EQt/treelas/blob/8618395a4b17fcaec8da63cf391ab5822e6e1fbb/julia/src/mgt.jl#L207-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TreeLas.MGT.gaplas!-Union{Tuple{Graph}, Tuple{Array{Float64,N} where N,Array{Float64,1},Array{Float64,1},Array{Float64,N} where N,Graph}} where Graph" href="#TreeLas.MGT.gaplas!-Union{Tuple{Graph}, Tuple{Array{Float64,N} where N,Array{Float64,1},Array{Float64,1},Array{Float64,N} where N,Graph}} where Graph"><code>TreeLas.MGT.gaplas!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gaplas!(...)</code></pre><p>Perform one iteration. Premises:</p><ol><li><code>x = y + D&#39;*α</code></li><li><code>α</code> dually feasible, <code>abs(α[e]) ≤ λ[e]</code> for all edges <code>e</code>.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/EQt/treelas/blob/8618395a4b17fcaec8da63cf391ab5822e6e1fbb/julia/src/mgt.jl#L174-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TreeLas.MGT.gaplas-Union{Tuple{Fu3}, Tuple{Fu2}, Tuple{Fu1}, Tuple{N}, Tuple{E}, Tuple{Array{Float64,N},Array{E,1},Array{Float64,1}}} where Fu3&lt;:Function where Fu2&lt;:Function where Fu1&lt;:Function where N where E" href="#TreeLas.MGT.gaplas-Union{Tuple{Fu3}, Tuple{Fu2}, Tuple{Fu1}, Tuple{N}, Tuple{E}, Tuple{Array{Float64,N},Array{E,1},Array{Float64,1}}} where Fu3&lt;:Function where Fu2&lt;:Function where Fu1&lt;:Function where N where E"><code>TreeLas.MGT.gaplas</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gaplas(y, edges, λ; learn=1.0, max_iter=3, ...)</code></pre><p>Optimize in each iteration along a tree.</p><p>The <code>learn</code> parameter controls how much of the new tree solution should be taken (should be between <span>$0$</span> and <span>$1.0$</span>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/EQt/treelas/blob/8618395a4b17fcaec8da63cf391ab5822e6e1fbb/julia/src/mgt.jl#L63-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TreeLas.MGT.gaplas-Union{Tuple{Graph}, Tuple{Array{Float64,N} where N,Graph}} where Graph" href="#TreeLas.MGT.gaplas-Union{Tuple{Graph}, Tuple{Array{Float64,N} where N,Graph}} where Graph"><code>TreeLas.MGT.gaplas</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gaplas(...)</code></pre><p>Graph has to implement several methods:</p><ul><li><code>iter_edges(::Function, ::Graph)</code></li><li><code>IncidenceIndex(::Graph)</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/EQt/treelas/blob/8618395a4b17fcaec8da63cf391ab5822e6e1fbb/julia/src/mgt.jl#L160-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TreeLas.MGT.update_tree!-NTuple{5,Any}" href="#TreeLas.MGT.update_tree!-NTuple{5,Any}"><code>TreeLas.MGT.update_tree!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">update_tree!(α, αt, selected, edges, parent)</code></pre><p>Update the global dual <code>α</code> by a tree dual <code>αt</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/EQt/treelas/blob/8618395a4b17fcaec8da63cf391ab5822e6e1fbb/julia/src/mgt.jl#L187-L191">source</a></section><h2><a class="nav-anchor" id="Utility-Functions-1" href="#Utility-Functions-1">Utility Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TreeLas.Utils.primal_objective-Union{Tuple{F2}, Tuple{F1}, Tuple{G}, Tuple{N}, Tuple{F}, Tuple{Array{F,N},Array{F,N},G}, Tuple{Array{F,N},Array{F,N},G,F2}} where F2 where F1 where G where N where F" href="#TreeLas.Utils.primal_objective-Union{Tuple{F2}, Tuple{F1}, Tuple{G}, Tuple{N}, Tuple{F}, Tuple{Array{F,N},Array{F,N},G}, Tuple{Array{F,N},Array{F,N},G,F2}} where F2 where F1 where G where N where F"><code>TreeLas.Utils.primal_objective</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">primal_objective(x, y, graph [, mu])</code></pre><p>Compute the objective function, i.e.</p><div>\[\frac{1}{2} \sum_{i=1}^n μ_i (x_i - y_i)^2 + \sum_{(i,j) \in E} λ_{ij} |x_i - x_j|\]</div><p>Hereby the edges (and edge weights <span>$λ_{ij}$</span>) are obtained via <code>enumerate_edges(graph)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/EQt/treelas/blob/8618395a4b17fcaec8da63cf391ab5822e6e1fbb/julia/src/utils.jl#L26-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TreeLas.Utils.sum2-Union{Tuple{Array{F,N}}, Tuple{N}, Tuple{F}} where N where F&lt;:Real" href="#TreeLas.Utils.sum2-Union{Tuple{Array{F,N}}, Tuple{N}, Tuple{F}} where N where F&lt;:Real"><code>TreeLas.Utils.sum2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sum2(x)</code></pre><p>Sum of squares.</p><pre><code class="language-julia-repl">julia&gt; TreeLas.Utils.sum2([1, 11])
122
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/EQt/treelas/blob/8618395a4b17fcaec8da63cf391ab5822e6e1fbb/julia/src/utils.jl#L6-L16">source</a></section><footer><hr/><a class="next" href="tree_dp.html"><span class="direction">Next</span><span class="title">Tree Solver</span></a></footer></article></body></html>
