#include <doctest/doctest.h>

#include <graphidx/bits/minmax.hpp>      // find_minmax
#include <graphidx/std/stack.hpp>
#include <graphidx/utils/timer.hpp>          // TimerQuiet

#include "../plotpwl.hpp"
#include "../tree_dp.hpp"
#include "../range.hpp"
#include "../event.hpp"
#include "../clip.hpp"
#include "../merge.hpp"


#ifdef __GNUC__
#  pragma GCC diagnostic push 
#  pragma GCC diagnostic ignored "-Wpedantic"
#endif

using doctest::Approx;


/* Test data generated by:
   ```julia
   include("test_cleantree.jl")
   TestFLSA2.compare(5)
   pq, proc_order, _ = FLSA2.init_queues(TestFLSA2.parent);
   println("{", join(["{$(p.start-1), $(p.stop-1)}" for p in pq], ",\n "), "}")
   println(proc_order-1)
   ```
*/
TEST_CASE("dptree: init_queues")
{
    TimerQuiet _;

    const std::vector<int> parent = {0, 0, 1, 2, 3, 0, 7, 8, 3, 8};
    const auto n = parent.size();
    std::vector<Range> pq (n);
    ChildrenIndex childs (parent);
    stack<int> stack;
    std::vector<int> proc_order;

    init_queues(n, pq, proc_order, childs, stack);

    const std::vector<Range> pq_expect {
        {21, 20},
        {20, 19},
        {19, 18},
        {18, 17},
        {17, 16},
        {4,   3},
        {13, 12},
        {14, 13},
        {15, 14},
        {10,  9}};
    for (size_t i = 0; i < n; i++) {
        CHECK(pq_expect[i].start -1 == pq[i].start);
        CHECK(pq_expect[i].stop -1 == pq[i].stop);
        // if (pq[i].start != pq_expect[i].start ||
        //     pq[i].stop != pq_expect[i].stop) {
        //     std::cerr << __FILE__ << ":" << __LINE__ << ": "
        //               << i << ": interval " << pq[i] << " vs " << pq_expect[i]
        //               << std::endl;
        // }
    }

    const std::vector<int> proc_order_expect {5, 9, 6, 7, 8, 4, 3, 2, 1};
    CHECK(proc_order_expect == proc_order);
    // for (int i = 0; i < n-1; i++) {
    //     CHECK(proc_order_expect[i] == proc_order[i]);
    //     // if (proc_order[i] != proc_order_expect[i]) {
    //     //     std::cerr << __FILE__ << ":" << __LINE__ << ": "
    //     //               << i << ": proc_order " << proc_order[i]
    //     //               << " vs " << proc_order_expect[i]
    //     //               << std::endl;
    //     //     std::cerr << proc_order << std::endl << "vs" << std::endl
    //     //               << proc_order_expect << std::endl;
    //     //     break;
    //     // }
    // }
}


/* inspired by `tiny3_test_merge2` in treequeue.jl
   ```julia
   println("{", join(map(string, round.(elements, 2)), ",\n "), "}")
   ```
 */
TEST_CASE("dptree: merge")
{
    Range
        parent {1, 3},
        child {8, 9};
    std::vector<double> elements =
        {0.0, 0.2, 0.22, 0.27, 0.0, 0.0, 0.0, 0.0, 0.48, 0.68, 0.0};

    const Range res = merge(parent, child, elements);
    // std::cerr << res << " vs " << Range({1,5}) << std::endl;
    CHECK(Range({1,5}) == res);
    std::vector<double> elements_expect =
        {0.0, 0.2, 0.22, 0.27, 0.48, 0.68, 0.0, 0.0, 0.48, 0.68, 0.0};

    // std::cerr << elements << std::endl << "vs" << std::endl
    //           << elements_expect << std::endl;
    CHECK(elements_expect == elements);
}


#ifndef _MSC_VER
TEST_CASE("dptree0: proc_order")
{
    /*
                              ┌───┐
                 ┌──────────▶ │ 0 │ ◀──────────┐
                 │            └───┘            │
                 │                             │
     ┌───┐     ┌───┐     ┌───┐     ┌───┐     ┌───┐     ┌───┐
     │ 6 │ ──▶ │ 2 │ ◀── │ 5 │     │ 4 │ ──▶ │ 1 │ ◀── │ 3 │
     └───┘     └───┘     └───┘     └───┘     └───┘     └───┘

    */
    TimerQuiet _;

    const std::vector<int> parent = {0, 0, 0, 1, 1, 2, 2};
    const int n = 7;
    REQUIRE(n == parent.size());
    std::vector<Range> pq (n);
    std::vector<int> proc_order;
    ChildrenIndex childs (parent);
    stack<int> stack;
    init_queues(n, pq, proc_order, childs, stack);

    const std::vector<int> proc_order_expect {6, 5, 2, 4, 3, 1};
    REQUIRE(proc_order_expect == proc_order);

    // const std::vector<int> numbers = {1, 3, 0, 2};
    const std::vector<double> y   = {0.0, 0.0, 0.0, 1.0, 3.0, 0.0, 2.0};
    const std::vector<double> mu  = {0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
    const std::vector<double> lam = {0.04, 0.02, 0.02, 0.01, 0.01, 0.01, 0.01};
    REQUIRE(n == y.size());
    REQUIRE(n == mu.size());
    REQUIRE(n == lam.size());

    double min_y, max_y;
    find_minmax(y.data(), n, min_y, max_y);
    REQUIRE(0.0 == min_y);
    REQUIRE(3.0 == max_y);

    std::vector<double> lb (n, 0), ub (n);
    std::vector<double>  &sig = lb;
    std::vector<Event> elements_ (2*n);
    Event *elements = elements_.data();

    REQUIRE(std::vector<double>({0.0, 0, 0, 0, 0, 0, 0}) == sig);
    {   int i = proc_order[0];
        REQUIRE(6 == i);
        REQUIRE(2 == parent[i]);
        REQUIRE(Range({4, 3}) == pq[i]);
        const auto lam_i = lam[i];
        sig[parent[i]] += lam_i;
        REQUIRE(0.01 == Approx(lam_i));
        REQUIRE(0.01 == Approx(sig[parent[i]]));
        REQUIRE(std::vector<double>({0.0, 0, 0.01, 0, 0, 0, 0}) == sig);
        const auto sig_i = sig[i];
        lb[i] = clip_front(elements, pq[i],
                           /* slope  */ +mu[i],
                           /* offset */ -mu[i]*y[i] -sig_i
                           /* t      */ +lam_i);
        REQUIRE(std::vector<double>({0.0, 0, 0.01, 0, 0, 0, 1.99}) == sig);
        REQUIRE(2.0 - 0.01 == Approx(lb[i]));
        REQUIRE(Range({3, 3}) == pq[i]);
        REQUIRE(elements[3] == Event({.x = lb[i], .slope = mu[i], ._offset = -mu[i]*y[i] + lam[i]}));

        ub[i] = clip_back  (elements, pq[i], mu[i], -mu[i]*y[i] +sig_i, +lam_i);
        REQUIRE(std::vector<double>({0.0, 0, 0.01, 0, 0, 0, 1.99}) == sig);
        REQUIRE(2.0 + 0.01 == Approx(ub[i]));
        REQUIRE(Range({3, 4}) == pq[i]);
        REQUIRE(Event({.x = ub[i], .slope = -mu[i], ._offset = +mu[i]*y[i] + lam[i]}) == elements[4]);

        REQUIRE(Range({7, 6}) == pq[parent[i]]);
        pq[parent[i]] = merge(pq[parent[i]], pq[i], elements);
        REQUIRE(Range({3, 4}) == pq[parent[i]]);
    }
    {   int i = proc_order[1];
        REQUIRE(5 == i);
        REQUIRE(2 == parent[i]);
        REQUIRE(Range({6, 5}) == pq[i]);
        const auto lam_i = lam[i];
        REQUIRE(0.01 == Approx(lam_i));
        sig[parent[i]] += lam_i;
        const auto sig_i = sig[i];
        REQUIRE(0.02 == Approx(sig[parent[i]]));
        REQUIRE(std::vector<double>({0.0, 0, 0.02, 0, 0, 0, 1.99}) == sig);
        REQUIRE(0.0 == Approx(sig_i));
        lb[i] = clip_front(elements, pq[i],
                           /* slope  */ +mu[i],
                           /* offset */ -mu[i]*y[i] -sig_i
                           /* t      */ +lam_i);
        REQUIRE(0.0 - 0.01 == Approx(lb[i]));
        REQUIRE(std::vector<double>({0.0, 0, 0.02, 0, 0, -0.01, 1.99}) == sig);
        REQUIRE(Range({5, 5}) == pq[i]);
        REQUIRE(Event({.x = lb[i], .slope = mu[i], ._offset = -mu[i]*y[i] + lam[i]}) == elements[5]);

        ub[i] = clip_back (elements, pq[i], mu[i], -mu[i]*y[i] +sig_i, +lam_i);
        REQUIRE(0.0 + 0.01 == Approx(ub[i]));
        REQUIRE(Range({5, 6}) == pq[i]);
        REQUIRE(Event({.x = ub[i], .slope = -mu[i], ._offset = +mu[i]*y[i] + lam[i]}) == elements[6]);

        REQUIRE(Range({3, 4}) == pq[parent[i]]);
        pq[parent[i]] = merge(pq[parent[i]], pq[i], elements);
        REQUIRE(Range({3, 6}) == pq[parent[i]]);
    }
    {   int i = proc_order[2];
        REQUIRE(2 == i);
        REQUIRE(0 == parent[i]);
        REQUIRE(Range({3, 6}) == pq[i]);
        const auto lam_i = lam[i];
        REQUIRE(0.02 == Approx(lam_i));
        REQUIRE(std::vector<double>({0.0, 0, 0.02, 0, 0, -0.01, 1.99}) == sig);
        REQUIRE(0.0 == Approx(sig[parent[i]]));
        sig[parent[i]] += lam_i;
        REQUIRE(std::vector<double>({0.02, 0, 0.02, 0, 0, -0.01, 1.99}) == sig);
        const auto sig_i = sig[i];
        REQUIRE(0.02 == Approx(sig_i));
        sort_events(pq[i], elements);
        REQUIRE(std::vector<double>({elements[3].x, elements[4].x, elements[5].x, elements[6].x}) ==
                std::vector<double>({-0.01, +0.01, +1.99, +2.01}));
        {
            Range &q = pq[i];
            double
                slope = +mu[i],
                offset = -mu[i]*y[i] -sig_i,
                t = -lam_i;
            auto &e = elements[q.start];
            REQUIRE(-0.02 == offset);
            REQUIRE(0.0 == slope);
            REQUIRE(Event({.x = -0.01, .slope = 1, ._offset=+0.01}) == e);
            REQUIRE(-0.02 == slope * e.x + offset);
            REQUIRE(-0.02 == t);
            REQUIRE(t == slope * e.x + offset);
            REQUIRE(q.stop >= q.start);
            lb[i] = clip_front(elements, pq[i],
                               /* slope  */ slope,
                               /* offset */ offset +
                               /* t      */ t);
            // REQUIRE(0.0 /*-0.01*/ == lb[i]);
            // REQUIRE(0.0 == offset - t);
            // REQUIRE(Range({3, 6}) == pq[i]);
            // // TODO: Think about merging those elments automatically
            // ASSERT_EQ(elements[2],
            //           Event({.x = -0.01, .slope = 0.0, ._offset = 0.0}));
            // ASSERT_EQ(elements[3],
            //           Event({.x = -0.01, .slope = 1.0, ._offset = 0.01}));
            // EXPECT_EQ(pq[i].start, 2) << pwl_csv(pq[i], elements) << std::endl;
        }
        /*
        {
            Range &q = pq[i];
            REQUIRE(q.stop >= q.start);
            auto &e = elements[q.stop];
            double
                slope = +mu[i],
                offset = -mu[i]*y[i] + sig_i,
                t = +lam_i;
            REQUIRE(+0.02 == offset);
            REQUIRE(+0.0 == slope);
            REQUIRE(Event({.x = +2.01, .slope = -1, ._offset = +2.01}) == e);
            REQUIRE(+0.02 == slope * e.x + offset);
            REQUIRE(+0.02 == t);
            REQUIRE(t == slope * e.x + offset);

            ub[i] = clip_back  (elements, q, slope, offset, t);
            REQUIRE(2.0 + 0.01 == Approx(ub[i]));
            REQUIRE(0.0 == offset - t);
            REQUIRE(Range({2, 7}) == pq[i]);
            ASSERT_EQ(elements[7],
                      Event({.x = +2.01, .slope = +0.0, ._offset = +0.00}));
            ASSERT_EQ(elements[6],
                      Event({.x = +2.01, .slope = -1.0, ._offset = +2.01}));
        }
        */

        // pq[parent[i]] = merge(pq[parent[i]], pq[i], elements);
        // REQUIRE(Range({2, 7}) == pq[parent[i]]);
    }
    /*
    {
        const int i = proc_order[3];
        REQUIRE(4 == i);
        const auto lam_i = lam[i];
        sig[parent[i]] += lam_i;
        const auto sig_i = sig[i];  // backup before it is set in next line
        lb[i] = clip_front(elements, pq[i], mu[i], -mu[i]*y[i] -sig_i, -lam_i);
        ub[i] = clip_back  (elements, pq[i], mu[i], -mu[i]*y[i] +sig_i, +lam_i);
        pq[parent[i]] = merge(pq[parent[i]], pq[i], elements);
    }
    {
        const int i = proc_order[4];
        REQUIRE(3 == i);
        const auto lam_i = lam[i];
        sig[parent[i]] += lam_i;
        const auto sig_i = sig[i];  // backup before it is set in next line
        lb[i] = clip_front(elements, pq[i], mu[i], -mu[i]*y[i] -sig_i, -lam_i);
        ub[i] = clip_back (elements, pq[i], mu[i], -mu[i]*y[i] +sig_i, +lam_i);
        pq[parent[i]] = merge(pq[parent[i]], pq[i], elements);
    }
    {
        const int i = proc_order[5];
        REQUIRE(1 == i);
        const auto lam_i = lam[i];
        const auto sig_i = sig[i];  // backup before it is set in next line
        sig[parent[i]] += lam_i;
        lb[i] = clip_front(elements, pq[i], mu[i], -mu[i]*y[i] -sig_i, -lam_i);
        ub[i] = clip_back (elements, pq[i], mu[i], -mu[i]*y[i] +sig_i, +lam_i);
        pq[parent[i]] = merge(pq[parent[i]], pq[i], elements);
    }
    {   // final merge
        REQUIRE(Range({2, 13}) == pq[0]);
        ASSERT_EQ(pwl_csv(pq[0], elements),
                  R"(-1.01,-0.04
-0.01,-0.04
-0.01,-0.04
+0.01,-0.02
+0.99,-0.02
+0.99,-0.02
+1.01,+0
+1.99,+0
+2.01,+0.02
+2.01,+0.02
+2.99,+0.02
+3.01,+0.04
+3.01,+0.04
+4.01,+0.04
)"
            );
    }
    {   // check bounds
        REQUIRE(+0.99 == lb[1]);
        REQUIRE(+3.01 == ub[1]);
        REQUIRE(-0.01 == lb[2]);
        REQUIRE(+2.01 == ub[2]);

        for (int i = 3; i < 6; i++) {
            ASSERT_EQ(lb[i], y[i] - lam[i]) << i;
            ASSERT_EQ(ub[i], y[i] + lam[i]) << i;
        }
    }
    {   // find root value
    }
    */
}
#  pragma GCC diagnostic pop
#endif
