var documenterSearchIndex = {"docs":
[{"location":"grid.html#Grid-Graphs-1","page":"Grid Graphs","title":"Grid Graphs","text":"","category":"section"},{"location":"grid.html#","page":"Grid Graphs","title":"Grid Graphs","text":"Modules = [GraphIdx.Grid]","category":"page"},{"location":"grid.html#GraphIdx.Grid","page":"Grid Graphs","title":"GraphIdx.Grid","text":"Computations related to grid graphs\n\n\n\n\n\n","category":"module"},{"location":"grid.html#GraphIdx.Grid.GridGraph","page":"Grid Graphs","title":"GraphIdx.Grid.GridGraph","text":"Capture all we need to know about a grid graph.\n\n\n\n\n\n","category":"type"},{"location":"grid.html#GraphIdx.Grid.ImplicitGridGraph","page":"Grid Graphs","title":"GraphIdx.Grid.ImplicitGridGraph","text":"Idea: Do not store the graph explicitly but compute the neighbors as needed. For avoiding too many allocations, return just a view to the buffer\n\n\n\n\n\n","category":"type"},{"location":"grid.html#GraphIdx.Grid.Pixel","page":"Grid Graphs","title":"GraphIdx.Grid.Pixel","text":"Position in a grid graph\n\n\n\n\n\n","category":"type"},{"location":"grid.html#GraphIdx.Grid.collect_edges-Tuple{GraphIdx.Grid.GridGraph}","page":"Grid Graphs","title":"GraphIdx.Grid.collect_edges","text":"collect_edges(::GridGraph)\n\nReturn a Vector{Tuple{Int,Int}} of edges and Vector{Float64} of weights.\n\n\n\n\n\n","category":"method"},{"location":"grid.html#GraphIdx.Grid.compute_dirs-Tuple{Int64}","page":"Grid Graphs","title":"GraphIdx.Grid.compute_dirs","text":"compute_dirs(dn)\n\nSetting the neighborhood degree (dn) to i will set all numbers less or equal i in the following diagram as neighbors of [*].\n\n[…] […] […] […] […] […] […]\n[…] […] [4] [3] [4] […] […]\n[…] [4] [2] [1] [2] [4] […]\n[…] [3] [1] [*] [1] [3] […]\n[…] [4] [2] [1] [2] [4] […]\n[…] […] [4] [3] [4] […] […]\n[…] […] […] […] […] […] […]\n\nExample\n\njulia> import GraphIdx.Grid: compute_dirs, Pixel\n\njulia> compute_dirs(2)\n2-element Array{Pixel,1}:\n Pixel(1, 0)\n Pixel(1, 1)\n\n\n\n\n\n","category":"method"},{"location":"grid.html#GraphIdx.Grid.iter_edges-Tuple{Function,Int64,Int64,Array{GraphIdx.Grid.Pixel,1}}","page":"Grid Graphs","title":"GraphIdx.Grid.iter_edges","text":"iter_edges(proc, n1, n2, dirs)\n\nCall proc(u::Int, v::Int, len::Float64) for every grid edge u -- v having length. Hereby u and v are the index of the corresponding grid-nodes.\n\n\n\n\n\n","category":"method"},{"location":"grid.html#GraphIdx.Grid.iter_edges_pixel-Tuple{Function,GraphIdx.Grid.GridGraph}","page":"Grid Graphs","title":"GraphIdx.Grid.iter_edges_pixel","text":"iter_edges_pixel(proc, g::GridGraph)\n\nIterate over the edges on a grid graph. Same as `iteredgespixel(::Function, ::Int, ::Int, ::Vector{Pixel}).\n\nExample\n\njulia> import GraphIdx.Grid: GridGraph, iter_edges_pixel\n\njulia> iter_edges_pixel(GridGraph(2, 3)) do i1, j1, i2, j2, len\n           println(\"($i1,$j1) -- ($i2,$j2): $len\")\n       end\n(1,1) -- (2,1): 1.0\n(1,2) -- (2,2): 1.0\n(1,3) -- (2,3): 1.0\n(1,1) -- (1,2): 1.0\n(1,2) -- (1,3): 1.0\n(2,1) -- (2,2): 1.0\n(2,2) -- (2,3): 1.0\n\n\n\n\n\n\n\n","category":"method"},{"location":"grid.html#GraphIdx.Grid.iter_edges_pixel-Tuple{Function,Int64,Int64,Array{GraphIdx.Grid.Pixel,1}}","page":"Grid Graphs","title":"GraphIdx.Grid.iter_edges_pixel","text":"iter_edges_pixel(proc, n1, n2, dirs)\n\nCall proc(i1, j1, i2, j2, len) for every grid edge (i1, j1) -- (i2, j2) having length.\n\n\n\n\n\n","category":"method"},{"location":"grid.html#GraphIdx.Grid.line_D-Tuple{Integer}","page":"Grid Graphs","title":"GraphIdx.Grid.line_D","text":"line_D(n)\n\nReturn the incidence matrix for a line graph of length n. Is equivalent to incmat(1, n, 1).\n\nExample\n\njulia> import GraphIdx.Grid: line_D\n\njulia> line_D(3)\n2×3 SparseArrays.SparseMatrixCSC{Float64,Int64} with 4 stored entries:\n  [1, 1]  =  1.0\n  [1, 2]  =  -1.0\n  [2, 2]  =  1.0\n  [2, 3]  =  -1.0\n\n\n\n\n\n\n","category":"method"},{"location":"grid.html#GraphIdx.Grid.lipschitz-Tuple{Any,Any,Array{GraphIdx.Grid.Pixel,1}}","page":"Grid Graphs","title":"GraphIdx.Grid.lipschitz","text":"lipschitz(n1, n2, [dn | dirs])\n\nCompute an upper bound for the Lipschitz-constant for ... TODO: Be more precise\n\n\n\n\n\n","category":"method"},{"location":"grid.html#GraphIdx.Grid.num_edges-Tuple{Int64,Int64,Array{GraphIdx.Grid.Pixel,1}}","page":"Grid Graphs","title":"GraphIdx.Grid.num_edges","text":"num_edges(n1, n2, dirs)\nnum_edges(n1, n2, dn::Int)\n\nNumber of edges in a grid graph n1×n2 along directions dirs. If called with last argument a number, first generate dirs.\n\n\n\n\n\n","category":"method"},{"location":"mst.html#Minimum-Spanning-Trees-1","page":"Minimum Spanning Trees","title":"Minimum Spanning Trees","text":"","category":"section"},{"location":"mst.html#Prim's-Algorithm-1","page":"Minimum Spanning Trees","title":"Prim's Algorithm","text":"","category":"section"},{"location":"mst.html#","page":"Minimum Spanning Trees","title":"Minimum Spanning Trees","text":"GraphIdx.prim_mst_edges","category":"page"},{"location":"mst.html#GraphIdx.prim_mst_edges","page":"Minimum Spanning Trees","title":"GraphIdx.prim_mst_edges","text":"prim_mst_edges(n, weights, [root = 1])\n\nPrim's algorithm for minimum spanning tree. Start from node root (will become the root node of the spanning tree).  Return the parent vector and a Boolean vector indicating for each edge whether the edge is part of the spanning tree.\n\n\n\n\n\n","category":"function"},{"location":"mst.html#","page":"Minimum Spanning Trees","title":"Minimum Spanning Trees","text":"The runtime is mathcalO(E log V) whereby E are the number of edges and V the number of nodes. We use an ordinary binary heap as priority queue:","category":"page"},{"location":"mst.html#","page":"Minimum Spanning Trees","title":"Minimum Spanning Trees","text":"Modules = [GraphIdx.Utils.Heap]","category":"page"},{"location":"mst.html#GraphIdx.Utils.Heap","page":"Minimum Spanning Trees","title":"GraphIdx.Utils.Heap","text":"PriorityQueue datastructure (based on a implicit binary heap). Code copied from DataStructures.jl (long time ago)\n\n\n\n\n\n","category":"module"},{"location":"mst.html#Base.setindex!-Union{Tuple{V}, Tuple{K}, Tuple{GraphIdx.Utils.Heap.PriorityQueue{K,V,O} where O<:Base.Order.Ordering,V,K}} where V where K","page":"Minimum Spanning Trees","title":"Base.setindex!","text":"Change the priority of an existing element, or equeue it if it isn't present.\n\n\n\n\n\n","category":"method"},{"location":"mst.html#Kruskal's-Algorithm-1","page":"Minimum Spanning Trees","title":"Kruskal's Algorithm","text":"","category":"section"},{"location":"mst.html#","page":"Minimum Spanning Trees","title":"Minimum Spanning Trees","text":"GraphIdx.kruskal_mst","category":"page"},{"location":"mst.html#GraphIdx.kruskal_mst","page":"Minimum Spanning Trees","title":"GraphIdx.kruskal_mst","text":"kruskal_mst(n, edges, weight)\n\nKruskal's minimum spanning tree algorithm. Return a vector indicating for each edge whether it is part of the spanning tree.\n\n\n\n\n\n","category":"function"},{"location":"mst.html#","page":"Minimum Spanning Trees","title":"Minimum Spanning Trees","text":"As you know, Kruskal's algorithm is best implemented using the UnionFind data structure which is useful on its own:","category":"page"},{"location":"mst.html#","page":"Minimum Spanning Trees","title":"Minimum Spanning Trees","text":"GraphIdx.Utils.UnionFind","category":"page"},{"location":"mst.html#GraphIdx.Utils.UnionFind","page":"Minimum Spanning Trees","title":"GraphIdx.Utils.UnionFind","text":"UnionFind(n)\n\nClassical Union-Find data structure with path compression as described e.g. in CLRS in Chapter 21 \"Disjooint Sets\" (3rd edition).\n\nExample\n\njulia> import GraphIdx.Utils: UnionFind, find, unite!\n\njulia> u = UnionFind(2);\n\njulia> find(u, 1) == find(u, 2)\nfalse\n\njulia> unite!(u, find(u, 1), find(u, 2));\n\njulia> find(u, 1) == find(u, 2)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"mst.html#","page":"Minimum Spanning Trees","title":"Minimum Spanning Trees","text":"To make sure that we cannot unite elements before we found its representative we introduce ","category":"page"},{"location":"mst.html#","page":"Minimum Spanning Trees","title":"Minimum Spanning Trees","text":"GraphIdx.Utils.Rep","category":"page"},{"location":"mst.html#GraphIdx.Utils.Rep","page":"Minimum Spanning Trees","title":"GraphIdx.Utils.Rep","text":"Representant of a partition in UnionFind.\n\n\n\n\n\n","category":"type"},{"location":"idx.html#Indexes-1","page":"Graph Indexes","title":"Indexes","text":"","category":"section"},{"location":"idx.html#General-Graphs-1","page":"Graph Indexes","title":"General Graphs","text":"","category":"section"},{"location":"idx.html#","page":"Graph Indexes","title":"Graph Indexes","text":"GraphIdx.IncidenceIndex\nGraphIdx.num_edges(::GraphIdx.IncidenceIndex)","category":"page"},{"location":"idx.html#GraphIdx.IncidenceIndex","page":"Graph Indexes","title":"GraphIdx.IncidenceIndex","text":"In a graph with numbered edges, provide access to neighbors and edge numbers for a specified node.\n\nnote: Note\nIncidenceIndex always includes both directions, i.e. for an edge (u, v) with edge index ei, it is (u, ei) ∈ neighbors[v] and (v, ei) ∈ neighbors[u].\n\n\n\n\n\n","category":"type"},{"location":"idx.html#GraphIdx.num_edges-Tuple{GraphIdx.IncidenceIndex}","page":"Graph Indexes","title":"GraphIdx.num_edges","text":"num_edges(::IncidenceIndex)\n\nActual number of (undirected) edges (not counting both directions).\n\n\n\n\n\n","category":"method"},{"location":"idx.html#Weights-1","page":"Graph Indexes","title":"Weights","text":"","category":"section"},{"location":"idx.html#","page":"Graph Indexes","title":"Graph Indexes","text":"Often, nodes or edges might have an associated weight. To give the optimizer the possibility to distinguish constant weights (all weights the same) from individual weights we provide the following structs:","category":"page"},{"location":"idx.html#","page":"Graph Indexes","title":"Graph Indexes","text":"GraphIdx.ConstantWeights\nGraphIdx.ArrayWeights","category":"page"},{"location":"idx.html#GraphIdx.ConstantWeights","page":"Graph Indexes","title":"GraphIdx.ConstantWeights","text":"Represent weighting that is indexable and callable where each index has the same value.\n\nUsually, weights are assumed to be positive!\n\nExample\n\njulia> w = GraphIdx.ConstantWeights(5.4);\n\njulia> w(3)\n5.4\n\njulia> w[3]\n5.4\n\n\n\n\n\n","category":"type"},{"location":"idx.html#GraphIdx.ArrayWeights","page":"Graph Indexes","title":"GraphIdx.ArrayWeights","text":"Weighting of nodes where every weight can be different. The actual value of a node can be accessed via call - or index syntax.\n\nExample\n\njulia> w = GraphIdx.ArrayWeights([0.1, 0.2, 0.3]);\n\njulia> w(3)\n0.3\n\njulia> w[1]\n0.1\n\n\n\n\n\n","category":"type"},{"location":"idx.html#Graph-Partition-1","page":"Graph Indexes","title":"Graph Partition","text":"","category":"section"},{"location":"idx.html#","page":"Graph Indexes","title":"Graph Indexes","text":"Modules = [GraphIdx.Cluster]","category":"page"},{"location":"idx.html#GraphIdx.Cluster.cluster-Union{Tuple{N}, Tuple{Any,N}} where N","page":"Graph Indexes","title":"GraphIdx.Cluster.cluster","text":"cluster(x, neigh, eps=1e-5, seed=42)\n\nFind a partition of x such that abs(x[i] - x[j]) < eps for all edges j in neighidx[i] where i and j are in the same partition.\n\n\n\n\n\n","category":"method"},{"location":"idx.html#Tree-Graphs-1","page":"Graph Indexes","title":"Tree Graphs","text":"","category":"section"},{"location":"idx.html#","page":"Graph Indexes","title":"Graph Indexes","text":"GraphIdx.Tree.ChildrenIndex\nGraphIdx.Tree.root_node(::GraphIdx.Tree.ChildrenIndex)","category":"page"},{"location":"idx.html#GraphIdx.Tree.ChildrenIndex","page":"Graph Indexes","title":"GraphIdx.Tree.ChildrenIndex","text":"Provide constant time access to children of a node by index operator.\n\nExample\n\njulia> cidx = GraphIdx.Tree.ChildrenIndex([1, 1, 2, 1]);\n\njulia> GraphIdx.Tree.root_node(cidx)\n1\n\njulia> collect(cidx[1])  # root node 1 has children 2 and 4\n2-element Array{Int64,1}:\n 2\n 4\n\njulia> collect(cidx[3])  # node 3 has no children\n0-element Array{Int64,1}\n\n\n\n\n\n\n","category":"type"},{"location":"idx.html#GraphIdx.Tree.root_node-Tuple{GraphIdx.Tree.ChildrenIndex}","page":"Graph Indexes","title":"GraphIdx.Tree.root_node","text":"root_node(::ChildrenIndex)\n\nReturn the root node of the underlying tree. This is possible because by convention the root node is stored at ChildrenIndex.idx[1].\n\n\n\n\n\n","category":"method"},{"location":"idx.html#","page":"Graph Indexes","title":"Graph Indexes","text":"Once, memory has been allocated we can re-use it to store different tree (of same size!) in it.","category":"page"},{"location":"idx.html#","page":"Graph Indexes","title":"Graph Indexes","text":"GraphIdx.Tree.reset!(::GraphIdx.Tree.ChildrenIndex, ::Vector{Int})","category":"page"},{"location":"idx.html#GraphIdx.Tree.reset!-Tuple{GraphIdx.Tree.ChildrenIndex,Array{Int64,1}}","page":"Graph Indexes","title":"GraphIdx.Tree.reset!","text":"reset!(cidx, parent [,root])\n\nActually compute the index according to parent.\n\n\n\n\n\n","category":"method"},{"location":"stats.html#Order-Statistics-1","page":"Order Statistics","title":"Order Statistics","text":"","category":"section"},{"location":"stats.html#","page":"Order Statistics","title":"Order Statistics","text":"Modules = [GraphIdx.Stats]","category":"page"},{"location":"stats.html#GraphIdx.Stats","page":"Order Statistics","title":"GraphIdx.Stats","text":"Some statistical functions, mainly related to (weighted) median computations.\n\n\n\n\n\n","category":"module"},{"location":"stats.html#GraphIdx.Stats.permcumsum-Union{Tuple{I}, Tuple{W}, Tuple{Array{W,N} where N,Array{I,1}}} where I<:Integer where W","page":"Order Statistics","title":"GraphIdx.Stats.permcumsum","text":"permcumsum(w, pi)\n\nReturn the cumulative sums over w in order pi.\n\n\n\n\n\n","category":"method"},{"location":"stats.html#GraphIdx.Stats.weighted_median-Union{Tuple{Array{X,1}}, Tuple{X}} where X","page":"Order Statistics","title":"GraphIdx.Stats.weighted_median","text":"weighted_median(x, [w, [∂ ]])\n\nCompute a generalized weighted order statistics. Hereby, we minimize\n\nmin_t sum_i w_i t - x_i + f(t)\n\nwhereby ∂ is the derivative of the convex function f (by default constant 0 for ordinary weighted median).\n\nReturn the interval a b containing the minimizer (if unique a = b).\n\ntodo: Todo\nCompare the sorting to binary search and median strategies. Maybe use SIMD for median.\n\n\n\n\n\n","category":"method"},{"location":"tree.html#Tree-Graphs-1","page":"Tree Graphs","title":"Tree Graphs","text":"","category":"section"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"GraphIdx.Tree","category":"page"},{"location":"tree.html#GraphIdx.Tree","page":"Tree Graphs","title":"GraphIdx.Tree","text":"Bundle functions regarding (rooted) tree graphs.\n\n\n\n\n\n","category":"module"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"For computing a spanning tree from within a general graph, see here. For debugging, outputting the tree as a hierarchy was usefule:","category":"page"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"GraphIdx.Tree.hierarchy\nGraphIdx.Tree.hierarchy_string\nGraphIdx.Tree.parenthesis\nGraphIdx.Tree.parenthesis_string","category":"page"},{"location":"tree.html#GraphIdx.Tree.hierarchy","page":"Tree Graphs","title":"GraphIdx.Tree.hierarchy","text":"hierarchy([io,] cidx, [indent])\n\nPrint a tree given by a ChildrenIndex hierarchically onto io (default stdout).\n\nExample\n\njulia> import GraphIdx.Tree: ChildrenIndex, hierarchy\n\njulia> hierarchy(ChildrenIndex([1, 1, 1, 3]))\n1\n├─2\n└─3\n  └─4\n\n\n\n\n\n\n","category":"function"},{"location":"tree.html#GraphIdx.Tree.hierarchy_string","page":"Tree Graphs","title":"GraphIdx.Tree.hierarchy_string","text":"hierarchy_string(cidx)\n\nSame as hierarchy but output as String. More precisely, print to a buffer and return as String.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#GraphIdx.Tree.parenthesis","page":"Tree Graphs","title":"GraphIdx.Tree.parenthesis","text":"parenthesis([io,] cidx [, stack])\n\nPrint the tree in parenthesis notation: recursively print <node id>(subtree). Per default output on stdout.\n\nExample\n\njulia> import GraphIdx.Tree: ChildrenIndex, parenthesis\n\njulia> parenthesis(ChildrenIndex([1, 1, 1, 3]))\n1(2()3(4()))\n\n\n\n\n\n\n","category":"function"},{"location":"tree.html#GraphIdx.Tree.parenthesis_string","page":"Tree Graphs","title":"GraphIdx.Tree.parenthesis_string","text":"parenthesis_string(cidx [, stack])\n\nLike parenthesis but return output as String.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Data-Structures-1","page":"Tree Graphs","title":"Data Structures","text":"","category":"section"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"We provide some framework specialized for (rooted) tree graphs:","category":"page"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"GraphIdx.Tree.RootedTree\nGraphIdx.Tree.find_root\nGraphIdx.Tree.node_degrees","category":"page"},{"location":"tree.html#GraphIdx.Tree.RootedTree","page":"Tree Graphs","title":"GraphIdx.Tree.RootedTree","text":"A rooted tree represanted by its parent vector, i.e. if u is the parent node of v then parent[v] == u. We always require that root is its own parent (parent[root] == root) and length(parent) == n.\n\nOften you might want to have a ChildrenIndex. For debugging, the hierarchy function might be useful.\n\n\n\n\n\n","category":"type"},{"location":"tree.html#GraphIdx.Tree.find_root","page":"Tree Graphs","title":"GraphIdx.Tree.find_root","text":"find_root(pi)\n\nFind the first index i with pi[i] == i. Report an error if non such exist.\n\nExample\n\njulia> GraphIdx.Tree.find_root([2, 1, 3, 2])\n3\n\n\n\n\n\n\n","category":"function"},{"location":"tree.html#GraphIdx.Tree.node_degrees","page":"Tree Graphs","title":"GraphIdx.Tree.node_degrees","text":"node_degrees(parent, [root = 1])\n\nReturn a vector telling the degree of each node.\n\n\n\n\n\n","category":"function"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"Often, we will need to access the children of arbitrary nodes; for this the GraphIdx.Tree.ChildrenIndex was developed.","category":"page"},{"location":"tree.html#Traversal-1","page":"Tree Graphs","title":"Traversal","text":"","category":"section"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"Classical depth first search","category":"page"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"GraphIdx.Tree.dfs_walk\nGraphIdx.Tree.dfs_walk_rev\nGraphIdx.Tree.dfs_finish","category":"page"},{"location":"tree.html#GraphIdx.Tree.dfs_walk","page":"Tree Graphs","title":"GraphIdx.Tree.dfs_walk","text":"dfs_walk(f, tree [,stack])\n\nCall f on each node of tree in depth-first search (DFS) order. Hereby the node v is negative v < 0 if the node is discovered the first time and non-negative (v >= 0) if the node has been finished.\n\nThe tree can be given as ChildrenIndex or parent Vector{Int}; in the latter case ChildrenIndex will be constructed. To avoid allocation, you can pass a stack Vector.\n\nExample\n\njulia> import GraphIdx.Tree: ChildrenIndex, hierarchy, dfs_walk\n\njulia> tree = ChildrenIndex([1, 1, 1, 3, 1]); hierarchy(tree)\n1\n├─2\n├─3\n│ └─4\n└─5\n\njulia> dfs_walk(tree) do v\n          println(v >= 0 ? \"finished   \" : \"discovered \", abs(v))\n       end\ndiscovered 1\ndiscovered 2\nfinished   2\ndiscovered 3\ndiscovered 4\nfinished   4\nfinished   3\ndiscovered 5\nfinished   5\nfinished   1\n    \n\n\n\n\n\n\n","category":"function"},{"location":"tree.html#GraphIdx.Tree.dfs_walk_rev","page":"Tree Graphs","title":"GraphIdx.Tree.dfs_walk_rev","text":"dfs_walk_rev(f, tree::ChildrenIndex [, stack])\n\nLike dfs_walk but process the children in reversed order!\n\nExample\n\njulia> import GraphIdx.Tree: ChildrenIndex, hierarchy, dfs_walk_rev\n\njulia> tree = ChildrenIndex([1, 1, 1, 3, 1]); hierarchy(tree)\n1\n├─2\n├─3\n│ └─4\n└─5\n\njulia> dfs_walk_rev(tree) do v\n          println(v >= 0 ? \"finished   \" : \"discovered \", abs(v))\n       end\ndiscovered 1\ndiscovered 5\nfinished   5\ndiscovered 3\ndiscovered 4\nfinished   4\nfinished   3\ndiscovered 2\nfinished   2\nfinished   1\n\n\n\n\n\n\n\n","category":"function"},{"location":"tree.html#GraphIdx.Tree.dfs_finish","page":"Tree Graphs","title":"GraphIdx.Tree.dfs_finish","text":"dfs_finish(parent)\n\nFor each node, compute the DFS finish time (without computing a ChildrenIndex).\n\njulia> import GraphIdx.Tree: ChildrenIndex, hierarchy, dfs_finish\n\njulia> pi = [1, 1, 2, 1, 2, 3]; hierarchy(ChildrenIndex(pi))\n1\n├─2\n│ ├─3\n│ │ └─6\n│ └─5\n└─4\n\njulia> dfs_finish(pi)\n6-element Array{Int64,1}:\n 6\n 3\n 5\n 2\n 4\n 1\n\n\n\n\n\n\n","category":"function"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"For binary trees, there is also the inorder:","category":"page"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"GraphIdx.Tree.binary_inorder","category":"page"},{"location":"tree.html#GraphIdx.Tree.binary_inorder","page":"Tree Graphs","title":"GraphIdx.Tree.binary_inorder","text":"Return the Inorder traversal of a complete binary tree with given height. (Root node will be 0 and placed in the middle of the array\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Lowest-Common-Ancestors-1","page":"Tree Graphs","title":"Lowest Common Ancestors","text":"","category":"section"},{"location":"tree.html#","page":"Tree Graphs","title":"Tree Graphs","text":"GraphIdx.Tree.lowest_common_ancestors","category":"page"},{"location":"tree.html#GraphIdx.Tree.lowest_common_ancestors","page":"Tree Graphs","title":"GraphIdx.Tree.lowest_common_ancestors","text":"lowest_common_ancestors(tree, parent, pairs)\n\nFor a list of pairs [(u1, v1), ..., (uk, vk)] compute the lowest common ancestors [a1, ..., ak], i.e. ai is the lowest node in the tree that is ancestor (parent, grand-parent, grand-grand-parent, etc.) of both, ui and vi.\n\nRuntime is O(length(tree) + length(pairs)). More precisely, due to the use of the UnionFind data structure, the inverse Ackermann function is also included; however the impact is at most 4 for all practical instances (n  10^100).\n\nSee CLRS (3rd edition) page 584 or networkx.\n\n\n\n\n\n","category":"function"},{"location":"index.html#GraphIdx.jl-1","page":"GraphIdx","title":"GraphIdx.jl","text":"","category":"section"},{"location":"index.html#","page":"GraphIdx","title":"GraphIdx","text":"This is the Julia part of GraphIdx, a framework for index-based graphs. Some parts are also implemented in","category":"page"},{"location":"index.html#","page":"GraphIdx","title":"GraphIdx","text":"C++ headers, or\na Rust crate.","category":"page"},{"location":"index.html#","page":"GraphIdx","title":"GraphIdx","text":"CurrentModule = GraphIdx","category":"page"},{"location":"index.html#","page":"GraphIdx","title":"GraphIdx","text":"The main module is","category":"page"},{"location":"index.html#","page":"GraphIdx","title":"GraphIdx","text":"GraphIdx","category":"page"},{"location":"index.html#GraphIdx.GraphIdx","page":"GraphIdx","title":"GraphIdx.GraphIdx","text":"Index-based Graphs\n\nNodes\n\nA node (sometimes also vertex called) in a graph is always represented as an integer. To be able to use a node as an index, the nodes should be within 1:n whereby n is the number of nodes. Furtheron, we always use signed integers because we might include extra information within the first (sign) bit.\n\nEdges\n\nBy convention, a graph is considered undirected (unless specified else). Hence we only need to store one direction of every edge (u, v); by default we assume u < v.\n\nTODO:\n\ndifferences\nincidence matrix\n\nIf any flow αfor an edge(u, v)has to be computed, the orientation is defined as going fromvtou` (big to small), i.e. we compute\n\nx[u] += α\nx[v] -= α\n\nSubmodules\n\nThe most important submodules are\n\nTree: Rooted Trees (including minimum spanning trees).\nGrid: Specialized code for grid graphs.\nLinA: Linear algebra (e.g. incidence matrix)\n\n\n\n\n\n","category":"module"},{"location":"index.html#Example-1","page":"GraphIdx","title":"Example","text":"","category":"section"},{"location":"index.html#","page":"GraphIdx","title":"GraphIdx","text":"Generate a random spanning tree on a 20×32 grid graph:","category":"page"},{"location":"index.html#","page":"GraphIdx","title":"GraphIdx","text":"import GraphIdx.Grid: GridGraph\nimport GraphIdx.IncidenceIndex\n\nTODO: Extend","category":"page"},{"location":"index.html#API-1","page":"GraphIdx","title":"API","text":"","category":"section"},{"location":"index.html#","page":"GraphIdx","title":"GraphIdx","text":"","category":"page"},{"location":"bits.html#Bit-Manipulations-1","page":"Bits and Bytes","title":"Bit Manipulations","text":"","category":"section"},{"location":"bits.html#","page":"Bits and Bytes","title":"Bits and Bytes","text":"Modules = [GraphIdx.Bits, GraphIdx.Io, GraphIdx.Io.Dimacs]","category":"page"},{"location":"bits.html#GraphIdx.Bits","page":"Bits and Bytes","title":"GraphIdx.Bits","text":"Some bit manipulation routines.\n\n\n\n\n\n","category":"module"},{"location":"bits.html#GraphIdx.Bits.hyperfloor-Tuple{Integer}","page":"Bits and Bytes","title":"GraphIdx.Bits.hyperfloor","text":"hyperfloor(x)\n\nHeighest power of 2 that is smaller than x.\n\nExample\n\njulia> bitstring(UInt8(123))\n\"01111011\"\n\njulia> bitstring(UInt8(GraphIdx.Bits.hyperfloor(123)))\n\"01000000\"\n\n\n\n\n\n","category":"method"},{"location":"bits.html#GraphIdx.Io","page":"Bits and Bytes","title":"GraphIdx.Io","text":"Input/output\n\n\n\n\n\n","category":"module"},{"location":"bits.html#GraphIdx.Io.Dimacs","page":"Bits and Bytes","title":"GraphIdx.Io.Dimacs","text":"Read/write DIMACS files\n\n\n\n\n\n","category":"module"},{"location":"bits.html#GraphIdx.Io.Dimacs.bin2asc","page":"Bits and Bytes","title":"GraphIdx.Io.Dimacs.bin2asc","text":"bin2asc(fname, out::IO)\n\nTransform from binary into asci representation.\n\n\n\n\n\n","category":"function"},{"location":"bits.html#GraphIdx.Io.Dimacs.read_dimacs_bin-Tuple{Function,String}","page":"Bits and Bytes","title":"GraphIdx.Io.Dimacs.read_dimacs_bin","text":"readdimacsbin(proc, fname)\n\nRead the binary file located at fname and call proc(u::Int, v::Int) on every edge (u, v) of the graph.\n\n\n\n\n\n","category":"method"},{"location":"bits.html#","page":"Bits and Bytes","title":"Bits and Bytes","text":"CurrentModule = GraphIdx","category":"page"},{"location":"lina.html#Linear-Algebra-1","page":"Linear Algebra","title":"Linear Algebra","text":"","category":"section"},{"location":"lina.html#","page":"Linear Algebra","title":"Linear Algebra","text":"Modules = [GraphIdx.LinA]","category":"page"},{"location":"lina.html#GraphIdx.LinA","page":"Linear Algebra","title":"GraphIdx.LinA","text":"Linear Algebra related graph functions. Especially, methods for handling incidence matrixes IncMat.\n\n\n\n\n\n","category":"module"},{"location":"lina.html#GraphIdx.LinA.IncMat","page":"Linear Algebra","title":"GraphIdx.LinA.IncMat","text":"IncMat(edges, λ, n [, T = Int])\n\nCreate an incidence matrix from a list of edges, weights λ having n nodes. The resulting matrix index will have type T.\n\n\n\n\n\n","category":"type"},{"location":"lina.html#GraphIdx.LinA.is_incmat-Tuple{SparseArrays.SparseMatrixCSC{Float64,Int64}}","page":"Linear Algebra","title":"GraphIdx.LinA.is_incmat","text":"is_incmat(::IncMat)\n\nCheck whether a matrix is a graph (oriented) edge-vertex incidence matrix.\n\n\n\n\n\n","category":"method"}]
}
